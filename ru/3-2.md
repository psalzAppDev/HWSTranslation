# UIActivityViewController объяснённый

Чтобы делиться чем-либо в iOS используется стандартный мощный компонент, которым могут воспользоваться и любые другие приложения. Поэтому он и должен стать отправной точкой при добавлении механизма "поделиться" в приложение. Этот компонент называется `UIActivityViewController`: вы сообщаете ему каким типом данных вы хотите поделиться, а он прикидывает как лучше это сделать.

Поскольку мы работаем с изображениями, `UIActivityViewController` автоматически предоставит нам функциональность, позволяющую поделиться через iMessage, email или Twitter и Facebook, наряду с возможностью сохранить изображение в фотопоток, присвоить контакту, распечатать с помощью AirPrint и не только. Он даже "подцепляется" к AirDrop и к системе iOS расширений (extensions) так, что другие приложения могут получить изображение напрямую от нашей программы.

И что самое приятное, потребуется всего несколько строк кода чтобы всё заработало. Но прежде чем мы возьмёмся за `UIActivityViewController`, мы сперва должны предоставить пользователям способ инициировать само действие "поделиться", и способ, которым мы собираемся это сделать заключается в добавлении элемента bar button.

Проект 1, если помните, использовал `UINavigationController` чтобы позволить пользователям перемещаться между двумя экранами. По умолчанию у `UINavigationController` наверху во всю ширину есть панель навигации - bar, называемый `UINavigationBar`, и как разработчики мы имеем возможность помещать в этот navigation bar кнопки, которые вызывают нужные нам методы.

Давайте прямо сейчас и создадим одну из этих кнопок. Для начала, сделайте копию существующей папки Project1 (целиком), и переименуйте её в Project3. Теперь запустите проект в XCode, откройте DetailViewController.swift, и найдите метод `viewDidLoad()`. Прямо под строкой `title =` добавьте 

    navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .action, target: self, action: #selector(shareTapped))

Сейчас вы получите ошибку, но так и должно быть; пожалуйста, читайте дальше.

Происходящее лекго разделить на две части: слева мы присваиваем значение `rightBarButtonItem` элементу нашего view controller `navigationItem`. Этот навигационный элемент (navigation item) используется навигационной панелью (navigation bar), что позволяет ей отображать релевантную информацию. В данном случае мы устанавливаем правый элемент-кнопку панели, и в правой части navigation bar появляется кнопка, когда этот view controller отображается.

С правой стороны мы создаём экземпляр  `UIBarButtonItem` устанавливая три его параметра системный предустановленный тип (system item), цель (target) и действие (action). В качестве системного типа мы задаём  `.action`, но вы можете набрать `.` чтобы предоставить системе автозавершения предложить вам все возможные варианты. Системный элемент типа `.action` отображается иконкой в виде стрелки направленной из рамки, символизируя, что пользователь сможет совершить некое действие при нажатии на него.

Параметры `target` и `action` идут рука об руку, потому что вместе они сообщают элементу `UIBarButtonItem` какой метод должен быть вызван. Параметр `action` говорит "когда на тебе тапнут, вызови метод `shareTapped()`", а параметр `target` говорит кнопке, что упомянутый метод принадлежит текущему view controller – `self`.

Часть связанная с  `#selector` требует дальнейших разъяснений, поскольку это новый и необычный синтаксис. Его смысл в том, что он сообщает компилятору Swift, что метод под названием "shareTapped" будет существовать и должен быть запущен по нажатию кнопки. Swift проверит это утверждение для вас: если мы по ошибке написали "shareTaped" - пропустив вторую P - Xcode откажется компилировать наше приложение пока мы не иправим опечатку.

Если ни одна из измеющихся системных bar кнопок вас не устраивает своим видом, вы можете создать собственную с нужным вам заголовком или картинкой. Однако, обычно предпочтительнее использовать имеющиеся в системе элементы, где возможно, потому что пользователи уже интутитивно знают, что эти элементы делают.

Теперь, когда кнопка bar button создана, время создать местод `shareTapped()`. Готовы ли вы для этого огромного количества замысловатого кода? Вот он! Поместите его сразу после метода `viewWillDisappear()`:

    @objc func shareTapped() {
        let vc = UIActivityViewController(activityItems: [imageView.image!], applicationActivities: [])
        vc.popoverPresentationController?.barButtonItem = navigationItem.rightBarButtonItem
        present(vc, animated: true)
    }

Готово. С этими тремя строчками кода  `shareTapped()` может отправлять фото через AirDrop, постить в Twitter и много чего ещё. Признайте, iOS может быть весьма изумительной иногда. 

Четвёртая строка знакомая; мы уже изучили  `present()` в project 2. Однако, строки 1, 2, и 3 новые, поэтому позвольте объяснить что они делают: 

- Строка 1 это имя метода, помеченное директивой  `@objc` потому что этот метод будет вызван Objective-C операционной системой лежащей в основе ( `UIBarButtonItem`), так что мы должны пометить метод соответственно, чтобы он был доступен для Objective-C кода. Когда вы вызываете метод через  `#selector` , необходимо чтобы он был помечен как `@objc`.
- Строка 2 создаёт  `UIActivityViewController`, который предоставляет типичный для iOS способ поделиться контентом с другими приложениями и службами.
- Строка 3 указывает iOS где должен быть прикреплён (в виде popover)  activity view controller – место, откуда он должен появиться.

На iPhone activity view controllers автоматически занимают весь экран, а на iPad они появляются в виде popover, так, что пользовательский контент заслоняется лишь частично. Третья строка сообщает iOS прикрепить activity view controller к правой кнопке панели (right bar button item) (к нашей кнопке "поделиться"), но эффект заметен лишь на iPad – на iPhone эта настройка игнорируется вледствии так называемой "адаптации".

**Tip:** Если вам интересно, то когда вы используете  `@IBAction` чтобы заставить storyboards вызывать код, это автоматически подразумевает `@objc` – Swift знает, что `@IBAction` имеет смысл только если может быть вызван Objective-C кодом.

Сфокусируемся на том как создаются activity view controllers. Как вы можете видеть в коде, инициализатору передаются два элемента: массив элементов, которыми вы хотите поделиться и массив любых своих служб приложений, присутствие которых в списке вы хотите обеспечить. В качестве второго параметра мы передаём пустой массив, посколько наше приложение не предлагает никаких служб. Но если бы вы развивали это приложение и, например,  добавили бы что-то вроде "Другие похожие фото", то вы могли бы предложить эту функциональность здесь.

Так что, в действительности, сфокусируемся на первом параметре: мы передаём `[imageView.image!]`. Если помните, изображение отображалось в `UIImageView` названном `imageView`, а у класса `UIImageView` есть optional свойство `image`, содержащее `UIImage`. Но оно optional, т.е. изображение может и отсутствовать.  `UIActivityViewController` не устроит тип "может есть, может нет" - ему нужны реальные  изображения, а не возможные.

К счастью, мы знаем точно, что наш `imageView` содежит изображение, потому что мы сами его установили! Изображение является сутью всего этого view controller. Так что, мы смело используем  `imageView.image!`, ставя восклицтельный знак в конце, разворачивая optional.

И... это всё. Нет, серьёзнно. Мы вроде как закончили: ваше приложение отныне поддерживает механизм "поделиться".

Не переживайте, если пока не всё понятно с  `@objc` -  мы к этому будем возвращаться снова и снова. Главное, запомнить, что если код Swift вызывает метод кода Swift, то не нужно помечать этот метод  `@objc`. А вот если код Objective-C обращается к методу Swift - нпример, когда любой из UI компонентов Apple, вызывает какой-либо метод, тогда  `@objc` *действительно* требуется.

![UIActivityViewController даёт возможность вашим пользователям поделиться, распечатать, сохранить и ещё много всего – и всё это при помощи лишь пары строк кода!](3-1.png)


## Исправляем маленький баг

В нынешней версии нашего кода есть маленький, но существенный баг. Если вы выберете "Сохранить изображение" ("Save Image" в англ. интерфейсе), вы столкнётесь с мгновенным вылетом программы. Происходит здесь вот что: наше приложение пытается получить доступ к библиотеке фото (photo library) пользователя, чтобы записать туда изображение, а на iOS так нельзя, если предварительно пользователь не предоставил соответвующее разрешение.

Чтобы иправить это, нужно отредактировать Info.plist файл нашего проекта. Мы ещё не затрагивали эту тему, но файл предназначен для хранения настроек конфигурации приложения, которые неизменны во времени.

Выберите Info.plist в project navigator, затем, когда увидите большую таблицу с какими-строчками, сделайте right-click на белом пространстве под ними. В появившемся меню выберите “Add Row” и вас должен возникнуть список опций, начинающийся с “Application Category”.

Вам нужно прокрутить вниз этот список и найти элемент “Privacy - Photo Library Additions Usage Description”. Это описание, которое будет показано пользователю, когда ваше приложение соберётся что либо добавить в photo library.

Когда вы выберете “Privacy - Photo Library Additions Usage Description”, то увидите справа “String”, и ещё правее будет пустая ячейка. Эта пустая ячейка - то место, куда вы можете вбить текст, показываемый пользователю, объясняющий, что собирается делать ваша программа с его библиотекой фото.

В этом приложении мы собираемся лишь сохранять картинки, поэтому поместите в текстовую ячейку вот такое описание: “Нужно сохранить понравившиеся фото.”

Попробуйте теперь запустить приложение. На этот раз при выборе "Сохранить изображение" появиться сообщение, спрашивающее согласие пользователя на доступ нашей программы к фото – гораздо лучше!
